<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Unity3D 跨平台通信 | 肚肚的小窝</title>
<meta name="description" content="Talk is cheap, Show me the code.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://duzexu.github.io/favicon.ico?v=1709367470012">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://duzexu.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154878038-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154878038-1');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://duzexu.github.io">
        <img src="https://duzexu.github.io/images/avatar.png?v=1709367470012" class="site-logo">
        <h1 class="site-title">肚肚的小窝</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/duzexu/" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Talk is cheap, Show me the code.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/duzexu/" target="_blank">duzexu</a> | <a class="rss" href="https://duzexu.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Unity3D 跨平台通信</h2>
            <div class="post-date">2022-11-22</div>
            
              <div class="feature-container" style="background-image: url('https://duzexu.github.io/post-images/unity3d-cross-flatform.png')">
              </div>
            
            <div class="post-content">
              <p>本文介绍Unity和iOS和Windows通信</p>
<!-- more -->
<h3 id="1-unity与c交互">1. Unity与C++交互</h3>
<p>Windows平台的SDK是C++编写的DLL库，所以我们需要Unity和C++进行通信</p>
<h4 id="11-基本概念">1.1 基本概念</h4>
<ul>
<li>托管(Managed)和非托管(Unmanaged)：.Net的运行环境是CLR(Common Language Runtime)，运行在CLR上的代码成为托管代码(Managed Code)，CLR提供了自动的垃圾回收机制(GC)。而C++是编译后直接由操作系统执行的代码，不运行在CLR上，所以C++属于非托管代码(Unmanaged Code)。</li>
<li>P/Invoke：P/Invoke（Platform Invoke，平台调用）使得我们可以在托管代码中调用非托管函数，Unity与C++的交互都是通过P/Invoke实现。（[DllImport]）</li>
</ul>
<h4 id="12-创建wrapper层c-dll">1.2 创建Wrapper层C++ DLL</h4>
<p>在VS中新建DLL项目，把引用的IM和RTC库拖入项目，在项目属性中设置好*.dll.lib链接地址以及头文件链接地址（如下图）<br>
<img src="https://duzexu.github.io/post-images/1669109075965.PNG" alt="" loading="lazy"><br>
<img src="https://duzexu.github.io/post-images/1669109190019.PNG" alt="" loading="lazy"><br>
<img src="https://duzexu.github.io/post-images/1669109197157.PNG" alt="" loading="lazy"><br>
<img src="https://duzexu.github.io/post-images/1669109202942.PNG" alt="" loading="lazy"><br>
新建一个类RTCInterface.h和RTCInterface.cpp</p>
<pre><code class="language-c++">//RTCInterface.h

extern &quot;C&quot;
{
    __declspec(dllexport) RCRTCEngine *rcrtc_create_engine(void* im_client);
    //__declspec(dllexport)必须添加
}
</code></pre>
<pre><code class="language-c++">//RTCInterface.cpp
#include &quot;RTCInterface.h&quot;

extern &quot;C&quot;
{
    RCRTCEngine *rcrtc_create_engine(void* im_client)
    {
        //code...
    }
}
</code></pre>
<h4 id="13-c调用">1.3 C#调用</h4>
<p>右键项目生成DLL后，将生成的DLL以及依赖的DLL拷贝到Unity项目对应架构的目录中，设置好对应的架构<br>
<img src="https://duzexu.github.io/post-images/1669109332762.PNG" alt="" loading="lazy"></p>
<p>在Unity中新建NativeWin.cs脚本</p>
<pre><code class="language-c#">//NativeWin.cs
namespace cn_rongcloud_rtc_unity
{
    internal class NativeWin
    {
        [DllImport(&quot;RTCWinWapper&quot;, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr rcrtc_create_engine(IntPtr client);
        //DllImport后面的名称需要和引入的DLL名称一致
    }
}
</code></pre>
<p>这样在C#中调用NativeWin的create方法就可以调用到C++的代码了</p>
<h4 id="14-其他情况">1.4 其他情况</h4>
<ul>
<li>参数中有类</li>
</ul>
<p>需要在C#和Wrapper中声明对应的结构体，C#端将C#类转为结构体，Wrapper中将结构体转为C++类</p>
<pre><code class="language-c#">//声明结构体
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
internal struct rtc_engine_setup
{
    [MarshalAs(UnmanagedType.U1)] 
    public bool reconnectable;

    public int statsReportInterval;

    [MarshalAs(UnmanagedType.U1)] 
    public bool enableSRTP;
    public IntPtr audioSetup;
    public IntPtr videoSetup;
    public string mediaUrl;
    public string logPath;
}

//声明方法
[DllImport(&quot;RTCWinWapper&quot;, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
internal static extern IntPtr rcrtc_create_engine_with_setup(IntPtr client, ref rtc_engine_setup setup);

//调用方法
internal RCRTCEngineWin(RCRTCEngineSetup setup)
{
    //转换成结构体
    rtc_engine_setup cobject;
    cobject.reconnectable = setup.IsReconnectable();
    if (setup.GetAudioSetup() != null)
    {
        rtc_audio_setup audio;
        audio.audioCodecType = (int)setup.GetAudioSetup().GetAudioCodecType();
        IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(audio));
        Marshal.StructureToPtr(audio, ptr, true);
        cobject.audioSetup = ptr;
     }
     else
     {
         cobject.audioSetup = IntPtr.Zero;
     }
     //other paramers...
     
     //调用方法
     rtc_engine = NativeWin.rcrtc_create_engine_with_setup(im_client, ref cobject);
     if (cobject.audioSetup != IntPtr.Zero)
     {
        Marshal.FreeHGlobal(cobject.audioSetup);
     }
}
</code></pre>
<p>注意：<br>
结构体中有Bool需要指定非托管类型为UnmanagedType.U1,可以告知运行时将字段作为 1 字节本机 bool 类型进行封送<br>
结构体中有其他的类需要使用Marshal.AllocHGlobal在非托管内存中分配内存，使用结束后需手动调用Marshal.FreeHGlobal释放</p>
<pre><code class="language-c++">//RTCInterface.cpp
#include &quot;RTCInterface.h&quot;

extern &quot;C&quot;
{
    //声明结构体
    typedef struct rtc_engine_setup
    {
        bool reconnectable;
        int statsReportInterval;
        bool enableSRTP;
        rtc_audio_setup* audioSetup;
        rtc_video_setup* videoSetup;
        const char* mediaUrl;
        const char* logPath;
    } rtc_engine_setup;

    RCRTCEngine *rcrtc_create_engine_with_setup(void *im_client, rtc_engine_setup *csetup)
    {
        RCRTCEngineSetup *setup = RCRTCEngineSetup::create();
        setup-&gt;setEnableSRTP(csetup-&gt;enableSRTP);
        //other params...
        RCRTCEngine *engine = RCRTCEngine::create(im_client, setup);
        return engine;
    }
}
</code></pre>
<ul>
<li>回调Unity方法</li>
</ul>
<pre><code class="language-c#">//C#中声明回调
public delegate void OnRoomJoinedDelegate(int code, String errMsg);

//实现回调方法
[MonoPInvokeCallback(typeof(OnRoomJoinedDelegate))]
private static void on_rtc_room_joined(int code, string message)
{
    //code...
}

//声明调用方法
[DllImport(&quot;RTCWinWapper&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
internal static extern void rcrtc_set_engine_listeners(OnRoomJoinedDelegate on_rtc_room_joined);

//设置回调 
NativeWin.rcrtc_set_engine_listeners(on_rtc_room_joined);
</code></pre>
<pre><code class="language-c++">extern &quot;C&quot;
{
    //wrapper中声明回调
    typedef void (*on_rtc_room_joined)(int code, const char* message);
    
    //声明调用方法
    void rcrtc_set_engine_listeners(on_rtc_room_joined _on_rtc_room_joined)
    {
        //直接调用
        _on_rtc_room_joined(0, &quot;error msg&quot;);
    }
}
</code></pre>
<h3 id="2-unity和ios交互">2. Unity和iOS交互</h3>
<p>Unity和iOS的交互和跟C++的交互过程基本一致，也是通过DllImport调用非托管函数</p>
<h4 id="21-创建wrapper层framework">2.1 创建Wrapper层framework</h4>
<p>新建Xcode framework项目,将使用的库拖入项目<br>
<img src="https://duzexu.github.io/post-images/1669110298035.PNG" alt="" loading="lazy"></p>
<p>新建一个交互类RongUnityRTC.mm</p>
<pre><code class="language-c++">//RongUnityRTC.mm

extern &quot;C&quot; {
    //声明结构体
    typedef struct rtc_engine_setup {
      bool reconnectable;
      int statsReportInterval;
      bool enableSRTP;
      rtc_audio_setup *audioSetup;
      rtc_video_setup *videoSetup;
      const char *mediaUrl;
    } rtc_engine_setup;
    
    //声明创建方法
    CFTypeRef rtc_create_engine_with_setup(rtc_engine_setup *csetup) {
      RCRTCIWEngineSetup *setup = [[RCRTCIWEngineSetup alloc] init];
      setup.enableSRTP = csetup-&gt;enableSRTP;
      if (csetup-&gt;audioSetup != NULL) {
        RCRTCIWAudioSetup *audioSetup = [[RCRTCIWAudioSetup alloc] init];
        audioSetup.type = (RCRTCIWAudioCodecType)csetup-&gt;audioSetup-&gt;audioCodecType;
        audioSetup.mixOtherAppsAudio = csetup-&gt;audioSetup-&gt;mixOtherAppsAudio;
        setup.audioSetup = audioSetup;
      }
      //other params...
      engine = [RCRTCIWEngine create:setup];
      return CFBridgingRetain(engine);
    }
    
    //声明回调
    typedef void (*on_rtc_room_joined)(int code, const char* message);
    
    //声明调用方法
    void rcrtc_set_engine_listeners(on_rtc_room_joined _on_rtc_room_joined)
    {
        //直接调用
        _on_rtc_room_joined(0, &quot;error msg&quot;);
    }
}
</code></pre>
<h4 id="22-c调用">2.2 C#调用</h4>
<p>Build wrapper项目，拷贝生成的framework以及依赖的frawork到Unity中，并设置好对应的架构<br>
<img src="https://duzexu.github.io/post-images/1669110428675.PNG" alt="" loading="lazy"><br>
在Unity中新建NativeIOS.cs脚本</p>
<pre><code class="language-c#">//NativeIOS.cs
namespace cn_rongcloud_rtc_unity
{
    //声明结构体
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    internal struct rtc_engine_setup
    {
        [MarshalAs(UnmanagedType.U1)] 
        public bool reconnectable;

        public int statsReportInterval;

        [MarshalAs(UnmanagedType.U1)] 
        public bool enableSRTP;
        public IntPtr audioSetup;
        public IntPtr videoSetup;
        public string mediaUrl;
        public string logPath;
    }

    internal class NativeIOS
    {
        [DllImport(&quot;__Internal&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        internal static extern IntPtr rtc_create_engine_with_setup(ref rtc_engine_setup setup);
        //DllImport后面的名称必须为__Internal

        [DllImport(&quot;__Internal&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        internal static extern void rcrtc_set_engine_listeners(OnRoomJoinedDelegate on_rtc_room_joined)
    }
}

//C#中声明回调
public delegate void OnRoomJoinedDelegate(int code, String errMsg);

//实现回调方法
[MonoPInvokeCallback(typeof(OnRoomJoinedDelegate))]
private static void on_rtc_room_joined(int code, string message)
{
    //code...
}
</code></pre>
<p>调用跟C++一致</p>
<pre><code class="language-c#">//调用方法
internal RCRTCEngineIOS(RCRTCEngineSetup setup)
{
    //设置回调 
    NativeIOS.rcrtc_set_engine_listeners(on_rtc_room_joined);
    //转换成结构体
    rtc_engine_setup cobject;
    cobject.reconnectable = setup.IsReconnectable();
    if (setup.GetAudioSetup() != null)
    {
        rtc_audio_setup audio;
        audio.audioCodecType = (int)setup.GetAudioSetup().GetAudioCodecType();
        IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(audio));
        Marshal.StructureToPtr(audio, ptr, true);
        cobject.audioSetup = ptr;
     }
     else
     {
         cobject.audioSetup = IntPtr.Zero;
     }
     //other paramers...
     
     //调用方法
     rtc_engine = NativeIOS.rcrtc_create_engine_with_setup(im_client, ref cobject);
     if (cobject.audioSetup != IntPtr.Zero)
     {
        Marshal.FreeHGlobal(cobject.audioSetup);
     }
}
</code></pre>
<h4 id="23-其他情况">2.3 其他情况</h4>
<ul>
<li>对象有继承关系</li>
</ul>
<p>c#为<code>ios_class_warpper</code>对象 , <code>type</code> 保存类名, <code>obj</code> 存真正的对象指针</p>
<pre><code class="language-c#">[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
internal struct ios_class_warpper
{
    public IntPtr obj;
    public string type;
}

internal static ios_class_warpper toMessageWapper(RCIMMessage message)
{
    ios_class_warpper message_wapper;
    if (message is RCIMUnknownMessage)
    {
        im_unknown_message cmessage = toUnknownMessage((RCIMUnknownMessage)message);
        IntPtr message_ptr = Marshal.AllocHGlobal(Marshal.SizeOf(cmessage));
        Marshal.StructureToPtr(cmessage, message_ptr, false);
        message_wapper.obj = message_ptr;
        message_wapper.type = &quot;RCIMIWUnknownMessage&quot;;
    }
    else if (message is RCIMCustomMessage)
    {
        //...
    }
}
</code></pre>
<p>oc转换则是根据type初始化对应的对象</p>
<pre><code class="language-Objective-C">+ (RCIMIWMessage *)fromMessageWapper:(struct ios_class_warpper *)cmessage {
  if (cmessage == NULL || cmessage-&gt;obj == NULL || cmessage-&gt;type == NULL) {
    return nil;
  }
  RCIMIWMessage *message_wapper = nil;
  NSString *type = [NSString stringWithUTF8String:cmessage-&gt;type];
  if ([type isEqualToString:@&quot;RCIMIWUnknownMessage&quot;]) {
    message_wapper =
        [self fromUnknownMessage:(im_unknown_message *)cmessage-&gt;obj];
  }else if //...
 }
</code></pre>
<p>转换回来的过程则是相反的</p>
<ul>
<li>数组</li>
</ul>
<p>c#转为 ios_c_list对象，list存数组指针，count存数组数量</p>
<pre><code class="language-c#">[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
internal struct ios_c_list
{
    public IntPtr list;
    public long count;
}

//转到ios
internal static IntPtr GetStructMapPointer&lt;StructType&gt;(ref List&lt;StructType&gt; clist)
{
     int size = Marshal.SizeOf(typeof(StructType));
     IntPtr list_ptr = Marshal.AllocHGlobal(clist.Count * size);
     for (int i = 0; i &lt; clist.Count; i++)
     {
          Marshal.StructureToPtr(clist[i], list_ptr+size*i, false);
     }
     ios_c_list map;
     map.list = list_ptr;
     map.count = clist.Count;
     IntPtr map_ptr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ios_c_list)));
     Marshal.StructureToPtr(map, map_ptr, false);
     return map_ptr;
}
//从ios转回
internal static List&lt;StructType&gt; GetObjectListByPtr&lt;StructType&gt;(IntPtr ptr)
{
    if (ptr == IntPtr.Zero)
    {
        return new List&lt;StructType&gt;();
    }
    ios_c_list clist = Marshal.PtrToStructure&lt;ios_c_list&gt;(ptr);
    StructType[] cobjects = new StructType[clist.count];
    for (uint i = 0; i &lt; clist.count; ++i)
    {
       IntPtr item_ptr = new IntPtr(ptr.ToInt64() + Marshal.SizeOf(typeof(StructType)) * i);

       if ((item_ptr != null))
       {
           cobjects.Add((StructType)Marshal.PtrToStructure(item_ptr, typeof(StructType)));
       }
    }
    return new List&lt;StructType&gt;(cobjects);
}
</code></pre>
<p>oc根据count遍历</p>
<pre><code class="language-oc">typedef struct ios_c_list {
  void *list;
  unsigned long count;
} ios_c_list;
//从c#
ios_class_warpper *messages_iter = c_list-&gt;list;
for (int i = 0; i &lt; c_list-&gt;count; i++) {
    //   messages_iter ... 
    messages_iter++;
}
//转到c#
//NSArray&lt;RCIMIWMessage *&gt; *messages = ...
 ios_c_list *clist = (ios_c_list *)malloc(sizeof(ios_c_list));
 memset(clist, 0, sizeof(ios_c_list));
 ios_class_warpper *cmessages = (ios_class_warpper *)malloc(
          sizeof(ios_class_warpper) * messages.count);
 memset(cmessages, 0, sizeof(ios_class_warpper) * messages.count);
 ios_class_warpper *messages_iter = cmessages;
 for (int i = 0; i &lt; messages.count; i++) {
     [RongUnityConvert makeMessageWapper:messages[i] to:messages_iter];
     messages_iter++;
 }
 clist-&gt;list = cmessages;
 clist-&gt;count = messages.count;
 return clist;
</code></pre>
<ul>
<li>字符串数组</li>
</ul>
<p>和数组不同的点是字符串需要转换为指针，则结构就是指针数组</p>
<pre><code class="language-c#">//转到ios
internal static IntPtr GetStringListPointer(List&lt;string&gt; clist)
{
      IntPtr[] ptrArray = new IntPtr[clist.Count];
      for (int i = 0; i &lt; clist.Count; i++)
      {
          ptrArray[i] = Marshal.StringToHGlobalAnsi(clist[i]);
      }
      IntPtr list_ptr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(IntPtr)) * clist.Count);
      for (int j = 0; j &lt; clist.Count; j++)
      {
          IntPtr item_ptr = new IntPtr(list_ptr.ToInt64() + Marshal.SizeOf(typeof(IntPtr)) * j);
          Marshal.StructureToPtr(ptrArray[j], item_ptr, false);
      }
      ios_c_list map;
      map.list = list_ptr;
      map.count = clist.Count;
      IntPtr result_ptr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ios_c_list)));
      Marshal.StructureToPtr(map, result_ptr, false);
      return result_ptr;
}
//从ios转回      
internal static List&lt;string&gt; GetStringListByPtr(IntPtr ptr)
{
    if (ptr == IntPtr.Zero)
    {
        return new List&lt;string&gt;();
    }
    ios_c_list clist = Marshal.PtrToStructure&lt;ios_c_list&gt;(ptr);
    List&lt;string&gt; cobjects = new List&lt;string&gt;();
    for (int i = 0; i &lt; clist.count; i++)
    {
        IntPtr item_ptr = new IntPtr(clist.list.ToInt64() + Marshal.SizeOf(typeof(IntPtr)) * i);
        IntPtr str_ptr = Marshal.PtrToStructure&lt;IntPtr&gt;(item_ptr);
        cobjects.Add(PtrToString(str_ptr));
    }
    return cobjects;
}
        
//需要注意释放
internal static void FreeStringListByPtr(IntPtr ptr)
{
     if (ptr == IntPtr.Zero)
     {
          return;
     }
     ios_c_list clist = Marshal.PtrToStructure&lt;ios_c_list&gt;(ptr);
     if (clist.list != IntPtr.Zero)
     {
         for (int i = 0; i &lt; clist.count; i++)
         {
             IntPtr item_ptr = new IntPtr(clist.list.ToInt64() + Marshal.SizeOf(typeof(IntPtr)) * i);
             IntPtr str_ptr = Marshal.PtrToStructure&lt;IntPtr&gt;(item_ptr);
             Marshal.FreeHGlobal(str_ptr);
         }
         Marshal.FreeHGlobal(clist.list);
     }
}
</code></pre>
<p>iOS接收采用<code>char*</code>数组接收</p>
<pre><code class="language-oc">//从c#
ios_c_list *clist = (ios_c_list *)cinfo-&gt;userIdList;
NSMutableArray&lt;NSString *&gt; *list =
        [[NSMutableArray alloc] initWithCapacity:clist-&gt;count];
char **iter = (char **)clist-&gt;list;
for (int i = 0; i &lt; clist-&gt;count; i++) {
  if (*iter != NULL) {
     [list addObject:[NSString stringWithUTF8String:*iter]];
  }
  iter++;
}
//从ios转回
//NSArray&lt;NSString *&gt; *keys = ...
ios_c_list *clist = (ios_c_list *)malloc(sizeof(ios_c_list));
memset(clist, 0, sizeof(ios_c_list));
char **cstrings = (char **)malloc(keys.count * sizeof(char *));
char **keys_iter = cstrings;
for (NSUInteger i = 0; i &lt; keys.count; i++) {
     NSString *string = keys[i];
     char *cstring = (char *)malloc(
            [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding] + 1);
     strncpy(cstring, [string UTF8String],
                [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding] + 1);
     *keys_iter = cstring;
     keys_iter++;
}
 clist-&gt;list = cstrings;
 clist-&gt;count = keys.count;
 return clist;
</code></pre>
<ul>
<li>字典</li>
</ul>
<p>转换为以<code>ios_c_map_item</code>为元素的数组</p>
<pre><code class="language-c#">[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
internal struct ios_c_map_item
{
    public string key;
    public string value;
}
</code></pre>
<h4 id="24-内存管理">2.4 内存管理</h4>
<p>调用完成后<br>
c# 非托管的需要手动释放<br>
C malloc的内存需要free</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://duzexu.github.io/tag/DWik8GwAS/" class="tag">
                    Unity
                  </a>
                
                  <a href="https://duzexu.github.io/tag/RVnblPRY4b/" class="tag">
                    iOS
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://duzexu.github.io/post/stm32-in-mac/">
                  <h3 class="post-title">
                    Mac搭建STM32环境（基于Apple silicon）
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '4b8d86672021766f0933',
        clientSecret: '7a92f6ba15717a3d5de8fb7dda58b9134cdd1757',
        repo: 'duzexu.github.io',
        owner: 'duzexu',
        admin: ['duzexu'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
